# 6장 키-값 저장소 설계

키-값 저장소는 NoSQL을 의미.

고유 식별자를 키로 가져야함

키는 일반 텍스트일 수도 있고 해시 값일 수도 있음

성능적인 관점으로 볼 때, 키는 짧을 수록 좋다.

### 단일 서버 키-값 저장소

한 대 서버만 사용하는 키-값 저장소 설계는 쉬움

가장 직관적인 방법으로는 키-값 쌍 전부를 메모리에 해시 테이블로 저장

하지만 모든 데이터를 메모리 안에 들고 있는 것을 불가능

이를 위해 데이터를 압축하거나, 자주쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장 함

하지만 이렇게 해도 데이터가 쌓이다 보면 한 대 서버로 부족한 때가 찾아옴

많은 데이터를 저장하려면 결국 분산 키-값 저장소를 사용해야 함

### 분산 키-값 저장소

분산 해시 테이블이라고도 불림

이를 설계할 때는 CAP 정리를 이해하고 있어야 함

### CAP 정리

데이터 일관성, 가용성, 파티션 감내라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리

데이터 일관성: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속하던지 언제나 같은 데이터를 본다.

가용성: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받을 수 있어야 한다.

파티션 감내: 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미. 파티션 감내는 네트워크에 파티션에 생기더라도 시스템은 정상 동작하는 뜻

결국 아래에서 세가지를 동시에 충족할 수는 없음

![1][1.png](./png/ch6/1.png)

CP 시스템: 일관성과 파티션 감내를 지원하는 키-값 저장소. 가용성 희생

AP 시스템: 가용성과 파티션 감내를 지원하는 키-값 저장소 데이터 일관성 희생

CA 시스템: 일관성과 가용성을 지원하는 키-값 저장소

파티션 감내를 지원하지 않는데, 현실에서 네트워크 장애를 피할 수 없는일이므로 CA 시스템은 존재하지 않음

만약 아래의 상황에서 장애가 발생한다고 가정해보자.

![2.png][2.png](./png/ch6/2.png)

가용성 대신 일관성을 선택한다면(CP 시스템)데이터 불일치를 해결하기 위해 복사 연산을 중단해야하는데, 그러면 가용성이 깨짐

일관성 대신 가용성을 선택한다면 이전 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용해야 함. 파티션 문제가 해결된 뒤에 새로운 데이터를 복제할 수 있음

### 시스템 컴포넌트

키-값 저장소 구현에 사용될 핵심 컴포넌트들

- 데이터 파티션
- 데이터 다중화
- 일관성
- 일관성 불일치 해소
- 장애 처리
- 시스템 아키텍처 다이어그램
- 쓰기 경로
- 읽기 경로

### 데이터 파티션

대규모 애플리케이션일 수록 전체 데이터를 한 대 서버에 넣을 수는 없음

가장 단순한 해결책은 데이터를 작은 파티션들로 분할한 후 여러 대 서버에 저장하는 것

데이터를 여러 서버에 고르게 분산할 수 있는지, 노드가 추가되거나 삭제될 때 데이터 이동을 최소화할 수 있는지 중요하게 따져봐야 함

5장에서 배웠던 안정 해시가 이 문제를 푸는데 적합한 기술

### 데이터 다중화

높은 가용성과 아정성을 위해 데이터를 N개의 서버에 비동기적으로 다중화 해야함

여기서 N은 튜닝 가능한 값

링을 순회하며 만나는 N개에 서버에 데이터를 복제

**물리 서버의 개수**가 N보다 적다면 선택된 N개의 가상 노드가 물리 서버에 매핑될 때 같은 물리 서버에 **중복 매핑**이 발생할 수 있음.

이 문제를 해결하려면 물리 서버를 중복 선택하지 않도록 해야함

### 데이터 일관성

정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있음

N: 사본 개수

W: 쓰기 연산에 대한 정족수. 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 함

R: 읽기 연산에 대한 정족수. 읽기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 읽기 연산이 성공했다는 응답을 받아야 함

R=1, W=N: 빠른 읽기 연산에 최적화된 시스템 W=1

R=N: 빠른 쓰기 연산에 최적화된 시스템

W+R>N: 강한 일관성이 보장됨 (보통 N=3, W=R=2)

W+RSN: 강한 일관성이 보장되지 않음

### 일관성 모델

종류

- 강한 일관성: 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환. 클라이언트는 절대로 낡은 데이터를 볼 수 없음 - 고가용성에서 적합하지 않음
- 약한 일관성: 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수도 있음
- 최종 일관성: 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영되는 모델

다이나모, 카산드라 같은 저장소는 최종 일관성 모델을 택하고 있음

최종 일관성 모델은 쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨어질 수 있는데, 이는 클라이언트가 해결해야 함

클라이언트측에서 데이터의 버전 정보를 활용해 일관성이 깨진 데이터를 읽지 못하도록 하는 기법을 사용

비 일관성 해소 기법: 데이터 버저닝

데이터를 다중화하면 가용성은 높아지지만 사본 간 일관성은 깨질 가능성이 높아짐

버저닝과, 벡터 시계가 해결책

버저닝: 각 버전의 데이터는 변경 불가능 함

동시에 데이터 변경시 충돌이 일어남.

벡터 시계 [서버, 버전] 순서쌍을 데이터에 매단 것

### 장애 감지

분산 시스템에서 단 한 대의 서버가 죽었다해서 장애 처리하지 않고, 두 대 이상의 서버가 똑같이 서버 A의 장애를 보고해야 실제 장애가 일어났다고 간주함

분산형 장애 감지 - 가십 프로토콜

멤버 ID : 박동 카운터, Time 으로 테이블이 구성됨

일종의 헬스 체크 역할

각 노드는 주기적으로 자신의 박동 카운터를 증가시킴

각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보냄

박동 카운터 목록을 받은 노드는 멤버십 목록을 최신 값으로 갱신함

어떤 멤버의 박동 카운터 값이 지정된 시간동안 갱신되지 않으면 해당 멤버는 장애상태인 것으로 간주 - 시간으로 판별

일시적 장애 처리

장애가 발생해도 다른 노드가 데이터를 처리해서 시스템이 계속 작동

데이터가 임시로 저장된 위치와 정보를 기록

원래 노드가 정상 상태로 돌아오면 데이터를 원래 위치로 넘김

시스템 아키텍처 다이어그램

키 - 값 저장소에서는 아래와 같이 사용

각 node는 수평 확장 되어있는 DB 중 하나

클라이언트가 get or put와 같은 키-값 요청을 보냄

중재자는 클라이언트 요청을 받아서 해당 키가 저장될 노드를 해싱을 통해 찾아냄

![3.png][2.png](./png/ch6/3.png)

![4.png][2.png](./png/ch6/4.png)